// // main.go - Versi√≥n optimizada para producci√≥n
// package main

// import (
// 	"flag"
// 	"fmt"
// 	"log"
// 	"os"
// 	"os/exec"
// 	"os/signal"
// 	"runtime"
// 	"sync"
// 	"syscall"
// 	"time"
// )

// // ============================================================================
// // CONFIGURACI√ìN Y CONSTANTES
// // ============================================================================

// const (
// 	// Modos de ejecuci√≥n disponibles
// 	ModeAll    = "all"
// 	ModeAPI    = "api"
// 	ModeWorker = "worker"
	
// 	// Timeouts
// 	ShutdownTimeout = 30 * time.Second
// 	StartupTimeout  = 60 * time.Second
// )

// // ProcessManager maneja los procesos del microservicio
// type ProcessManager struct {
// 	apiCmd    *exec.Cmd
// 	workerCmd *exec.Cmd
// 	mode      string
// 	mutex     sync.RWMutex
// 	shutdown  chan os.Signal
// 	done      chan bool
// }

// // ============================================================================
// // FUNCI√ìN PRINCIPAL
// // ============================================================================

// func main() {
// 	// Configurar logger con informaci√≥n detallada
// 	log.SetFlags(log.LstdFlags | log.Lshortfile)
// 	log.Println("üöÄ Iniciando Auth Microservice...")

// 	// Mostrar informaci√≥n del sistema
// 	logSystemInfo()

// 	// Parsear argumentos de l√≠nea de comandos
// 	mode := flag.String("mode", ModeAll, "Modo de ejecuci√≥n: all, api, worker")
// 	help := flag.Bool("help", false, "Mostrar ayuda")
// 	version := flag.Bool("version", false, "Mostrar versi√≥n")
// 	flag.Parse()

// 	// Manejar flags especiales
// 	if *help {
// 		showHelp()
// 		return
// 	}

// 	if *version {
// 		showVersion()
// 		return
// 	}

// 	// Validar modo de ejecuci√≥n
// 	if !isValidMode(*mode) {
// 		log.Fatalf("‚ùå Modo inv√°lido: %s. Use 'all', 'api' o 'worker'", *mode)
// 	}

// 	// Detectar si estamos en un contenedor Docker
// 	isDocker := isRunningInDocker()
// 	if isDocker {
// 		log.Println("üê≥ Detectado entorno Docker")
// 	}

// 	// Crear y configurar el manejador de procesos
// 	pm := &ProcessManager{
// 		mode:     *mode,
// 		shutdown: make(chan os.Signal, 1),
// 		done:     make(chan bool, 1),
// 	}

// 	// Configurar manejo de se√±ales del sistema
// 	signal.Notify(pm.shutdown, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP)

// 	// Iniciar los componentes seg√∫n el modo
// 	if err := pm.StartComponents(isDocker); err != nil {
// 		log.Fatalf("‚ùå Error iniciando componentes: %v", err)
// 	}

// 	// Esperar se√±al de terminaci√≥n
// 	log.Println("‚úÖ Microservicio iniciado correctamente")
// 	log.Println("üí° Presiona Ctrl+C para terminar")
	
// 	<-pm.shutdown
// 	log.Println("üõë Se√±al de terminaci√≥n recibida...")

// 	// Realizar shutdown graceful
// 	if err := pm.GracefulShutdown(); err != nil {
// 		log.Printf("‚ö†Ô∏è  Error durante shutdown: %v", err)
// 		os.Exit(1)
// 	}

// 	log.Println("üëã Auth Microservice terminado correctamente")
// }

// // ============================================================================
// // GESTI√ìN DE PROCESOS
// // ============================================================================

// // StartComponents inicia los componentes seg√∫n el modo especificado
// func (pm *ProcessManager) StartComponents(isDocker bool) error {
// 	log.Printf("üéØ Modo de ejecuci√≥n: %s", pm.mode)

// 	switch pm.mode {
// 	case ModeAll:
// 		return pm.startBothComponents(isDocker)
// 	case ModeAPI:
// 		return pm.startAPIOnly(isDocker)
// 	case ModeWorker:
// 		return pm.startWorkerOnly(isDocker)
// 	default:
// 		return fmt.Errorf("modo no soportado: %s", pm.mode)
// 	}
// }

// // startBothComponents inicia tanto el API como el Worker
// func (pm *ProcessManager) startBothComponents(isDocker bool) error {
// 	log.Println("üîÑ Iniciando API Server y Worker...")

// 	// Iniciar API Server
// 	if err := pm.startAPI(isDocker); err != nil {
// 		return fmt.Errorf("error iniciando API: %v", err)
// 	}

// 	// Esperar un momento para que el API se estabilice
// 	time.Sleep(2 * time.Second)

// 	// Iniciar Worker
// 	if err := pm.startWorker(isDocker); err != nil {
// 		// Si el worker falla, detener el API tambi√©n
// 		pm.stopAPI()
// 		return fmt.Errorf("error iniciando Worker: %v", err)
// 	}

// 	log.Println("‚úÖ API Server y Worker iniciados correctamente")
// 	pm.logProcessInfo()

// 	return nil
// }

// // startAPIOnly inicia solo el API Server
// func (pm *ProcessManager) startAPIOnly(isDocker bool) error {
// 	log.Println("üåê Iniciando solo API Server...")

// 	if err := pm.startAPI(isDocker); err != nil {
// 		return fmt.Errorf("error iniciando API: %v", err)
// 	}

// 	log.Println("‚úÖ API Server iniciado correctamente")
// 	pm.logProcessInfo()

// 	return nil
// }

// // startWorkerOnly inicia solo el Worker
// func (pm *ProcessManager) startWorkerOnly(isDocker bool) error {
// 	log.Println("‚öôÔ∏è  Iniciando solo Worker...")

// 	if err := pm.startWorker(isDocker); err != nil {
// 		return fmt.Errorf("error iniciando Worker: %v", err)
// 	}

// 	log.Println("‚úÖ Worker iniciado correctamente")
// 	pm.logProcessInfo()

// 	return nil
// }

// // startAPI inicia el proceso del API Server
// func (pm *ProcessManager) startAPI(isDocker bool) error {
// 	pm.mutex.Lock()
// 	defer pm.mutex.Unlock()

// 	var cmd *exec.Cmd

// 	if isDocker {
// 		// En Docker, usar el binario compilado
// 		cmd = exec.Command("./auth-api")
// 	} else {
// 		// En desarrollo, usar go run si est√° disponible
// 		if isGoAvailable() {
// 			cmd = exec.Command("go", "run", "cmd/api/main.go")
// 		} else {
// 			// Fallback: intentar usar binario local si existe
// 			if _, err := os.Stat("./auth-api"); err == nil {
// 				cmd = exec.Command("./auth-api")
// 			} else {
// 				return fmt.Errorf("ni 'go' ni binario './auth-api' est√°n disponibles")
// 			}
// 		}
// 	}

// 	pm.apiCmd = cmd
// 	pm.apiCmd.Stdout = os.Stdout
// 	pm.apiCmd.Stderr = os.Stderr
	
// 	// Propagar variables de entorno
// 	pm.apiCmd.Env = os.Environ()

// 	// Iniciar proceso
// 	if err := pm.apiCmd.Start(); err != nil {
// 		return fmt.Errorf("error iniciando proceso API: %v", err)
// 	}

// 	log.Printf("üåê API Server iniciado con PID: %d", pm.apiCmd.Process.Pid)
// 	return nil
// }

// // startWorker inicia el proceso del Worker
// func (pm *ProcessManager) startWorker(isDocker bool) error {
// 	pm.mutex.Lock()
// 	defer pm.mutex.Unlock()

// 	var cmd *exec.Cmd

// 	if isDocker {
// 		// En Docker, usar el binario compilado
// 		cmd = exec.Command("./auth-worker")
// 	} else {
// 		// En desarrollo, usar go run si est√° disponible
// 		if isGoAvailable() {
// 			cmd = exec.Command("go", "run", "cmd/worker/main.go")
// 		} else {
// 			// Fallback: intentar usar binario local si existe
// 			if _, err := os.Stat("./auth-worker"); err == nil {
// 				cmd = exec.Command("./auth-worker")
// 			} else {
// 				return fmt.Errorf("ni 'go' ni binario './auth-worker' est√°n disponibles")
// 			}
// 		}
// 	}

// 	pm.workerCmd = cmd
// 	pm.workerCmd.Stdout = os.Stdout
// 	pm.workerCmd.Stderr = os.Stderr
	
// 	// Propagar variables de entorno
// 	pm.workerCmd.Env = os.Environ()

// 	// Iniciar proceso
// 	if err := pm.workerCmd.Start(); err != nil {
// 		return fmt.Errorf("error iniciando proceso Worker: %v", err)
// 	}

// 	log.Printf("‚öôÔ∏è  Worker iniciado con PID: %d", pm.workerCmd.Process.Pid)
// 	return nil
// }

// // ============================================================================
// // GRACEFUL SHUTDOWN
// // ============================================================================

// // GracefulShutdown realiza un cierre ordenado de todos los componentes
// func (pm *ProcessManager) GracefulShutdown() error {
// 	log.Println("üîÑ Iniciando shutdown graceful...")

// 	pm.mutex.Lock()
// 	defer pm.mutex.Unlock()

// 	var errors []error

// 	// Crear canal para coordinar el shutdown
// 	shutdownDone := make(chan bool, 1)
	
// 	// Ejecutar shutdown en goroutine separada
// 	go func() {
// 		defer func() { shutdownDone <- true }()

// 		// Detener Worker primero (procesa eventos)
// 		if pm.workerCmd != nil && pm.workerCmd.Process != nil {
// 			if err := pm.stopWorker(); err != nil {
// 				errors = append(errors, fmt.Errorf("error deteniendo Worker: %v", err))
// 			}
// 		}

// 		// Luego detener API (maneja peticiones HTTP)
// 		if pm.apiCmd != nil && pm.apiCmd.Process != nil {
// 			if err := pm.stopAPI(); err != nil {
// 				errors = append(errors, fmt.Errorf("error deteniendo API: %v", err))
// 			}
// 		}
// 	}()

// 	// Esperar shutdown con timeout
// 	select {
// 	case <-shutdownDone:
// 		if len(errors) > 0 {
// 			log.Printf("‚ö†Ô∏è  Shutdown completado con errores:")
// 			for _, err := range errors {
// 				log.Printf("   - %v", err)
// 			}
// 			return fmt.Errorf("shutdown con %d errores", len(errors))
// 		}
// 		log.Println("‚úÖ Shutdown graceful completado exitosamente")
// 		return nil
		
// 	case <-time.After(ShutdownTimeout):
// 		log.Printf("‚ö†Ô∏è  Timeout de shutdown (%v) alcanzado, forzando terminaci√≥n", ShutdownTimeout)
// 		pm.forceKillAll()
// 		return fmt.Errorf("shutdown timeout")
// 	}
// }

// // stopAPI detiene el proceso del API de forma ordenada
// func (pm *ProcessManager) stopAPI() error {
// 	if pm.apiCmd == nil || pm.apiCmd.Process == nil {
// 		return nil
// 	}

// 	pid := pm.apiCmd.Process.Pid
// 	log.Printf("üõë Deteniendo API Server (PID: %d)...", pid)

// 	// Enviar SIGTERM para shutdown graceful
// 	if err := pm.apiCmd.Process.Signal(syscall.SIGTERM); err != nil {
// 		log.Printf("‚ö†Ô∏è  Error enviando SIGTERM al API: %v", err)
		
// 		// Si falla, intentar SIGKILL
// 		if killErr := pm.apiCmd.Process.Kill(); killErr != nil {
// 			return fmt.Errorf("error forzando terminaci√≥n del API: %v", killErr)
// 		}
// 	}

// 	// Esperar que termine
// 	if err := pm.apiCmd.Wait(); err != nil {
// 		log.Printf("‚ö†Ô∏è  API termin√≥ con error: %v", err)
// 	} else {
// 		log.Println("‚úÖ API Server detenido correctamente")
// 	}

// 	pm.apiCmd = nil
// 	return nil
// }

// // stopWorker detiene el proceso del Worker de forma ordenada
// func (pm *ProcessManager) stopWorker() error {
// 	if pm.workerCmd == nil || pm.workerCmd.Process == nil {
// 		return nil
// 	}

// 	pid := pm.workerCmd.Process.Pid
// 	log.Printf("üõë Deteniendo Worker (PID: %d)...", pid)

// 	// Enviar SIGTERM para shutdown graceful
// 	if err := pm.workerCmd.Process.Signal(syscall.SIGTERM); err != nil {
// 		log.Printf("‚ö†Ô∏è  Error enviando SIGTERM al Worker: %v", err)
		
// 		// Si falla, intentar SIGKILL
// 		if killErr := pm.workerCmd.Process.Kill(); killErr != nil {
// 			return fmt.Errorf("error forzando terminaci√≥n del Worker: %v", killErr)
// 		}
// 	}

// 	// Esperar que termine
// 	if err := pm.workerCmd.Wait(); err != nil {
// 		log.Printf("‚ö†Ô∏è  Worker termin√≥ con error: %v", err)
// 	} else {
// 		log.Println("‚úÖ Worker detenido correctamente")
// 	}

// 	pm.workerCmd = nil
// 	return nil
// }

// // forceKillAll fuerza la terminaci√≥n de todos los procesos
// func (pm *ProcessManager) forceKillAll() {
// 	if pm.apiCmd != nil && pm.apiCmd.Process != nil {
// 		log.Printf("üö® Forzando terminaci√≥n del API (PID: %d)", pm.apiCmd.Process.Pid)
// 		pm.apiCmd.Process.Kill()
// 	}

// 	if pm.workerCmd != nil && pm.workerCmd.Process != nil {
// 		log.Printf("üö® Forzando terminaci√≥n del Worker (PID: %d)", pm.workerCmd.Process.Pid)
// 		pm.workerCmd.Process.Kill()
// 	}
// }

// // ============================================================================
// // FUNCIONES AUXILIARES
// // ============================================================================

// // isValidMode verifica si el modo de ejecuci√≥n es v√°lido
// func isValidMode(mode string) bool {
// 	validModes := []string{ModeAll, ModeAPI, ModeWorker}
// 	for _, validMode := range validModes {
// 		if mode == validMode {
// 			return true
// 		}
// 	}
// 	return false
// }

// // isRunningInDocker detecta si estamos ejecutando en un contenedor Docker
// func isRunningInDocker() bool {
// 	// M√©todo 1: Verificar archivo .dockerenv
// 	if _, err := os.Stat("/.dockerenv"); err == nil {
// 		return true
// 	}

// 	// M√©todo 2: Verificar cgroup
// 	if data, err := os.ReadFile("/proc/1/cgroup"); err == nil {
// 		content := string(data)
// 		if len(content) > 0 && (
// 			// Docker patterns
// 			contains(content, "docker") ||
// 			contains(content, "/docker/") ||
// 			// Kubernetes patterns
// 			contains(content, "kubepods") ||
// 			// Container patterns
// 			contains(content, "container")) {
// 			return true
// 		}
// 	}

// 	// M√©todo 3: Verificar hostname (contenedores suelen tener hostnames aleatorios)
// 	hostname, _ := os.Hostname()
// 	if len(hostname) == 12 || len(hostname) == 64 {
// 		// Docker containers often have 12-char or 64-char hostnames
// 		return true
// 	}

// 	return false
// }

// // contains verifica si una cadena contiene una subcadena
// func contains(s, substr string) bool {
// 	return len(s) >= len(substr) && (s == substr || 
// 		len(s) > len(substr) && (
// 			s[:len(substr)] == substr ||
// 			s[len(s)-len(substr):] == substr ||
// 			stringContains(s, substr)))
// }

// // stringContains implementaci√≥n simple de contains
// func stringContains(s, substr string) bool {
// 	for i := 0; i <= len(s)-len(substr); i++ {
// 		if s[i:i+len(substr)] == substr {
// 			return true
// 		}
// 	}
// 	return false
// }

// // isGoAvailable verifica si el comando 'go' est√° disponible
// func isGoAvailable() bool {
// 	_, err := exec.LookPath("go")
// 	return err == nil
// }

// // logSystemInfo muestra informaci√≥n del sistema
// func logSystemInfo() {
// 	log.Printf("üíª Sistema: %s/%s", runtime.GOOS, runtime.GOARCH)
// 	log.Printf("üêπ Go version: %s", runtime.Version())
// 	log.Printf("üî¢ CPUs disponibles: %d", runtime.NumCPU())
// 	log.Printf("üìã PID del proceso principal: %d", os.Getpid())
// }

// // logProcessInfo muestra informaci√≥n de los procesos en ejecuci√≥n
// func (pm *ProcessManager) logProcessInfo() {
// 	pm.mutex.RLock()
// 	defer pm.mutex.RUnlock()

// 	log.Println("üìä Procesos en ejecuci√≥n:")
	
// 	if pm.apiCmd != nil && pm.apiCmd.Process != nil {
// 		log.Printf("   - API Server: PID %d", pm.apiCmd.Process.Pid)
// 	}
	
// 	if pm.workerCmd != nil && pm.workerCmd.Process != nil {
// 		log.Printf("   - Worker: PID %d", pm.workerCmd.Process.Pid)
// 	}
// }

// // showHelp muestra la ayuda del programa
// func showHelp() {
// 	fmt.Println("üöÄ Auth Microservice")
// 	fmt.Println()
// 	fmt.Println("Uso:")
// 	fmt.Printf("  %s [opciones]\n", os.Args[0])
// 	fmt.Println()
// 	fmt.Println("Opciones:")
// 	fmt.Println("  -mode string")
// 	fmt.Println("        Modo de ejecuci√≥n: all, api, worker (default \"all\")")
// 	fmt.Println("  -help")
// 	fmt.Println("        Mostrar esta ayuda")
// 	fmt.Println("  -version")
// 	fmt.Println("        Mostrar versi√≥n")
// 	fmt.Println()
// 	fmt.Println("Modos de ejecuci√≥n:")
// 	fmt.Println("  all     - Ejecutar API Server y Worker (por defecto)")
// 	fmt.Println("  api     - Ejecutar solo API Server")
// 	fmt.Println("  worker  - Ejecutar solo Worker")
// 	fmt.Println()
// 	fmt.Println("Ejemplos:")
// 	fmt.Printf("  %s                    # Ejecutar ambos componentes\n", os.Args[0])
// 	fmt.Printf("  %s -mode=api          # Solo API Server\n", os.Args[0])
// 	fmt.Printf("  %s -mode=worker       # Solo Worker\n", os.Args[0])
// 	fmt.Println()
// 	fmt.Println("Variables de entorno importantes:")
// 	fmt.Println("  DATABASE_HOST         - Host de la base de datos")
// 	fmt.Println("  DATABASE_PORT         - Puerto de la base de datos")
// 	fmt.Println("  DATABASE_USER         - Usuario de la base de datos")
// 	fmt.Println("  DATABASE_PASSWORD     - Contrase√±a de la base de datos")
// 	fmt.Println("  DATABASE_NAME         - Nombre de la base de datos")
// 	fmt.Println("  AUTH_JWT_SECRET       - Secreto para tokens JWT")
// 	fmt.Println("  SERVER_PORT           - Puerto del API Server")
// 	fmt.Println("  RABBITMQ_URL          - URL de conexi√≥n a RabbitMQ")
// }

// // showVersion muestra la versi√≥n del microservicio
// func showVersion() {
// 	fmt.Println("üöÄ Auth Microservice")
// 	fmt.Printf("   Version: %s\n", getVersion())
// 	fmt.Printf("   Go version: %s\n", runtime.Version())
// 	fmt.Printf("   Built: %s\n", getBuildTime())
// 	fmt.Printf("   Git commit: %s\n", getGitCommit())
// }

// // getVersion retorna la versi√≥n del microservicio
// func getVersion() string {
// 	// En producci√≥n, esto deber√≠a venir de build flags
// 	return "1.0.0-production"
// }

// // getBuildTime retorna la fecha de compilaci√≥n
// func getBuildTime() string {
// 	// En producci√≥n, esto deber√≠a venir de build flags
// 	return time.Now().Format("2006-01-02 15:04:05")
// }

// // getGitCommit retorna el commit de git
// func getGitCommit() string {
// 	// En producci√≥n, esto deber√≠a venir de build flags
// 	return "unknown"
// }

// main.go (ra√≠z del proyecto)
package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"runtime"
	"strings"
	// "sync"
	"syscall"
	"time"
)

// ============================================================================
// VARIABLES GLOBALES Y CONFIGURACI√ìN
// ============================================================================

var (
	// WaitGroup para coordinar procesos
	// wg sync.WaitGroup
	
	// Canales para coordinar shutdown
	shutdownChan = make(chan os.Signal, 1)
	
	// PIDs de los procesos
	apiProcess    *os.Process
	workerProcess *os.Process
)

// ============================================================================
// FUNCI√ìN PRINCIPAL
// ============================================================================

func main() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	log.Println("üöÄ Iniciando Auth Microservice...")
	
	// Mostrar informaci√≥n del sistema
	logSystemInfo()
	
	// Determinar modo de ejecuci√≥n
	mode := determineRunMode()
	log.Printf("üéØ Modo de ejecuci√≥n: %s", mode)
	
	// Configurar manejo de se√±ales (CORREGIDO PARA WINDOWS)
	setupSignalHandling()
	
	// Ejecutar seg√∫n el modo
	switch mode {
	case "api":
		runAPIOnly()
	case "worker":
		runWorkerOnly()
	case "all":
		runBothProcesses()
	default:
		log.Fatalf("‚ùå Modo de ejecuci√≥n desconocido: %s", mode)
	}
}

// ============================================================================
// CONFIGURACI√ìN Y UTILIDADES
// ============================================================================

// setupSignalHandling configura el manejo de se√±ales (CORREGIDO)
func setupSignalHandling() {
	log.Printf("üîß Configurando manejo de se√±ales para %s", runtime.GOOS)
	
	// ‚úÖ CORRECCI√ìN PARA WINDOWS
	if runtime.GOOS == "windows" {
		signal.Notify(shutdownChan, os.Interrupt, syscall.SIGTERM)
		log.Println("ü™ü Configuraci√≥n de se√±ales para Windows aplicada")
	} else {
		signal.Notify(shutdownChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP)
		log.Println("üêß Configuraci√≥n de se√±ales para Unix/Linux aplicada")
	}
}

// logSystemInfo muestra informaci√≥n del sistema
func logSystemInfo() {
	log.Printf("üíª Sistema: %s/%s", runtime.GOOS, runtime.GOARCH)
	log.Printf("üêπ Go version: %s", runtime.Version())
	log.Printf("üî¢ CPUs disponibles: %d", runtime.NumCPU())
	log.Printf("üìã PID del proceso principal: %d", os.Getpid())
}

// determineRunMode determina el modo de ejecuci√≥n basado en argumentos
func determineRunMode() string {
	if len(os.Args) > 1 {
		switch os.Args[1] {
		case "api", "server":
			return "api"
		case "worker", "worker-only":
			return "worker"
		case "all", "both":
			return "all"
		default:
			log.Printf("‚ö†Ô∏è  Argumento desconocido: %s, usando modo 'all'", os.Args[1])
		}
	}
	return "all" // Modo por defecto
}

// ============================================================================
// MODOS DE EJECUCI√ìN
// ============================================================================

// runAPIOnly ejecuta solo el API server
func runAPIOnly() {
	log.Println("üåê Iniciando solo API Server...")
	
	cmd := exec.Command("go", "run", "cmd/api/main.go")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	
	if err := cmd.Start(); err != nil {
		log.Fatalf("‚ùå Error iniciando API Server: %v", err)
	}
	
	apiProcess = cmd.Process
	log.Printf("üåê API Server iniciado con PID: %d", apiProcess.Pid)
	
	// Esperar se√±al de terminaci√≥n
	<-shutdownChan
	log.Println("üõë Se√±al de terminaci√≥n recibida...")
	
	// Detener API gracefully
	stopProcessGracefully(apiProcess, "API Server")
	
	log.Println("üëã Auth Microservice terminado correctamente")
}

// runWorkerOnly ejecuta solo el worker
func runWorkerOnly() {
	log.Println("‚öôÔ∏è  Iniciando solo Worker...")
	
	cmd := exec.Command("go", "run", "cmd/worker/main.go")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	
	if err := cmd.Start(); err != nil {
		log.Fatalf("‚ùå Error iniciando Worker: %v", err)
	}
	
	workerProcess = cmd.Process
	log.Printf("‚öôÔ∏è  Worker iniciado con PID: %d", workerProcess.Pid)
	
	// Esperar se√±al de terminaci√≥n
	<-shutdownChan
	log.Println("üõë Se√±al de terminaci√≥n recibida...")
	
	// Detener worker gracefully
	stopProcessGracefully(workerProcess, "Worker")
	
	log.Println("üëã Auth Microservice terminado correctamente")
}

// runBothProcesses ejecuta tanto API como Worker
func runBothProcesses() {
	log.Println("üîÑ Iniciando API Server y Worker...")
	
	// Iniciar API Server
	apiCmd := exec.Command("go", "run", "cmd/api/main.go")
	apiCmd.Stdout = os.Stdout
	apiCmd.Stderr = os.Stderr
	
	if err := apiCmd.Start(); err != nil {
		log.Fatalf("‚ùå Error iniciando API Server: %v", err)
	}
	
	apiProcess = apiCmd.Process
	log.Printf("üåê API Server iniciado con PID: %d", apiProcess.Pid)
	
	// Esperar un poco antes de iniciar el worker
	time.Sleep(2 * time.Second)
	
	// Iniciar Worker
	workerCmd := exec.Command("go", "run", "cmd/worker/main.go")
	workerCmd.Stdout = os.Stdout
	workerCmd.Stderr = os.Stderr
	
	if err := workerCmd.Start(); err != nil {
		log.Fatalf("‚ùå Error iniciando Worker: %v", err)
	}
	
	workerProcess = workerCmd.Process
	log.Printf("‚öôÔ∏è  Worker iniciado con PID: %d", workerProcess.Pid)
	
	log.Println("‚úÖ API Server y Worker iniciados correctamente")
	
	// Mostrar informaci√≥n de procesos
	logProcessInfo()
	
	log.Println("‚úÖ Microservicio iniciado correctamente")
	log.Println("üí° Presiona Ctrl+C para terminar")
	
	// Esperar se√±al de terminaci√≥n
	<-shutdownChan
	log.Println("üõë Se√±al de terminaci√≥n recibida...")
	
	// Coordinar shutdown de ambos procesos
	performGracefulShutdown()
	
	log.Println("üëã Auth Microservice terminado correctamente")
}

// ============================================================================
// GESTI√ìN DE PROCESOS
// ============================================================================

// stopProcessGracefully detiene un proceso de forma ordenada (CORREGIDO)
func stopProcessGracefully(process *os.Process, name string) error {
	if process == nil {
		return nil
	}
	
	log.Printf("üõë Deteniendo %s (PID: %d)...", name, process.Pid)
	
	// ‚úÖ CORRECCI√ìN MEJORADA PARA WINDOWS
	if runtime.GOOS == "windows" {
		// En Windows, intentar terminaci√≥n suave primero usando taskkill
		log.Printf("ü™ü Intentando terminaci√≥n suave de %s en Windows...", name)
		
		// Intentar taskkill /PID primero (terminaci√≥n suave)
		taskkillCmd := exec.Command("taskkill", "/PID", fmt.Sprintf("%d", process.Pid))
		if err := taskkillCmd.Run(); err != nil {
			log.Printf("‚ö†Ô∏è  Taskkill suave fall√≥ para %s: %v", name, err)
			
			// Si falla, intentar terminaci√≥n forzada
			log.Printf("ü™ü Intentando terminaci√≥n forzada de %s...", name)
			taskkillForceCmd := exec.Command("taskkill", "/F", "/PID", fmt.Sprintf("%d", process.Pid))
			if forceErr := taskkillForceCmd.Run(); forceErr != nil {
				log.Printf("‚ö†Ô∏è  Taskkill forzado tambi√©n fall√≥ para %s: %v", name, forceErr)
				
				// Como √∫ltimo recurso, usar process.Kill()
				log.Printf("ü™ü Usando process.Kill() como √∫ltimo recurso para %s...", name)
				if killErr := process.Kill(); killErr != nil {
					log.Printf("‚ö†Ô∏è  process.Kill() tambi√©n fall√≥ para %s: %v", name, killErr)
					// No retornar error aqu√≠, continuar con el wait
				}
			}
		}
	} else {
		// En Unix/Linux, usar SIGTERM primero
		log.Printf("üêß Enviando SIGTERM a %s...", name)
		if err := process.Signal(syscall.SIGTERM); err != nil {
			log.Printf("‚ö†Ô∏è  Error enviando SIGTERM a %s: %v", name, err)
			// Si SIGTERM falla, usar Kill
			if killErr := process.Kill(); killErr != nil {
				log.Printf("‚ö†Ô∏è  Error con Kill en %s: %v", name, killErr)
				return killErr
			}
		}
	}
	
	// Esperar que el proceso termine con timeout extendido para Windows
	timeout := 15 * time.Second
	if runtime.GOOS == "windows" {
		timeout = 20 * time.Second // M√°s tiempo en Windows
	}
	
	done := make(chan error, 1)
	go func() {
		_, err := process.Wait()
		done <- err
	}()
	
	select {
	case err := <-done:
		if err != nil {
			log.Printf("‚ö†Ô∏è  %s termin√≥ con error: %v", name, err)
		} else {
			log.Printf("‚úÖ %s detenido correctamente", name)
		}
		return err
	case <-time.After(timeout):
		log.Printf("‚ö†Ô∏è  Timeout (%v) esperando que termine %s", timeout, name)
		
		// Verificar si el proceso a√∫n existe
		if isProcessRunning(process) {
			log.Printf("‚ö†Ô∏è  %s a√∫n est√° ejecut√°ndose despu√©s del timeout", name)
			if runtime.GOOS == "windows" {
				// En Windows, intentar taskkill forzado una vez m√°s
				log.Printf("ü™ü √öltimo intento con taskkill /F para %s...", name)
				taskkillForceCmd := exec.Command("taskkill", "/F", "/PID", fmt.Sprintf("%d", process.Pid))
				if err := taskkillForceCmd.Run(); err != nil {
					log.Printf("‚ö†Ô∏è  Taskkill forzado fall√≥: %v", err)
				}
				
				// Esperar un poco y verificar nuevamente
				time.Sleep(2 * time.Second)
				if isProcessRunning(process) {
					log.Printf("‚ö†Ô∏è  %s SIGUE ejecut√°ndose despu√©s de taskkill /F", name)
					return fmt.Errorf("proceso %s (PID: %d) no pudo ser terminado", name, process.Pid)
				} else {
					log.Printf("‚úÖ %s finalmente terminado con taskkill /F", name)
				}
			} else {
				// En Unix/Linux, usar SIGKILL
				process.Signal(syscall.SIGKILL)
				time.Sleep(1 * time.Second)
				if isProcessRunning(process) {
					return fmt.Errorf("proceso %s (PID: %d) no pudo ser terminado", name, process.Pid)
				}
			}
		} else {
			log.Printf("‚úÖ %s ya no est√° ejecut√°ndose", name)
		}
		
		return nil
	}
}

// performGracefulShutdown coordina el shutdown de ambos procesos
func performGracefulShutdown() {
	log.Println("üîÑ Iniciando shutdown graceful...")
	
	errors := []error{}
	
	// Detener Worker primero (para que deje de procesar eventos)
	if workerProcess != nil {
		log.Println("üîÑ Deteniendo Worker...")
		if err := stopProcessGracefully(workerProcess, "Worker"); err != nil {
			errors = append(errors, fmt.Errorf("error deteniendo Worker: %v", err))
		}
		// Dar tiempo para que el worker termine completamente
		time.Sleep(2 * time.Second)
	}
	
	// Luego detener API Server
	if apiProcess != nil {
		log.Println("üîÑ Deteniendo API Server...")
		if err := stopProcessGracefully(apiProcess, "API Server"); err != nil {
			errors = append(errors, fmt.Errorf("error deteniendo API: %v", err))
		}
		// Dar tiempo para que el API termine completamente
		time.Sleep(2 * time.Second)
	}
	
	// Verificaci√≥n final de procesos
	log.Println("üîç Verificando estado final de procesos...")
	allStopped := true
	
	if workerProcess != nil && isProcessRunning(workerProcess) {
		log.Printf("‚ö†Ô∏è  Worker (PID: %d) a√∫n est√° ejecut√°ndose", workerProcess.Pid)
		allStopped = false
		
		// Intentar terminaci√≥n forzada final
		log.Printf("üö® Forzando terminaci√≥n final del Worker (PID: %d)...", workerProcess.Pid)
		if runtime.GOOS == "windows" {
			taskkillCmd := exec.Command("taskkill", "/F", "/PID", fmt.Sprintf("%d", workerProcess.Pid))
			if err := taskkillCmd.Run(); err != nil {
				log.Printf("‚ö†Ô∏è  Error en terminaci√≥n forzada final del Worker: %v", err)
			} else {
				log.Printf("‚úÖ Worker terminado forzadamente")
			}
		}
	}
	
	if apiProcess != nil && isProcessRunning(apiProcess) {
		log.Printf("‚ö†Ô∏è  API Server (PID: %d) a√∫n est√° ejecut√°ndose", apiProcess.Pid)
		allStopped = false
		
		// Intentar terminaci√≥n forzada final
		log.Printf("üö® Forzando terminaci√≥n final del API Server (PID: %d)...", apiProcess.Pid)
		if runtime.GOOS == "windows" {
			taskkillCmd := exec.Command("taskkill", "/F", "/PID", fmt.Sprintf("%d", apiProcess.Pid))
			if err := taskkillCmd.Run(); err != nil {
				log.Printf("‚ö†Ô∏è  Error en terminaci√≥n forzada final del API Server: %v", err)
			} else {
				log.Printf("‚úÖ API Server terminado forzadamente")
			}
		}
	}
	
	// Reportar resultado del shutdown
	if len(errors) > 0 {
		log.Printf("‚ö†Ô∏è  Shutdown completado con errores:")
		for _, err := range errors {
			log.Printf("   - %v", err)
		}
	} else if !allStopped {
		log.Println("‚ö†Ô∏è  Shutdown completado pero algunos procesos pueden seguir ejecut√°ndose")
	} else {
		log.Println("‚úÖ Shutdown graceful completado exitosamente")
	}
	
	// En Windows, dar tiempo adicional para que el sistema libere recursos
	if runtime.GOOS == "windows" {
		log.Println("ü™ü Esperando liberaci√≥n de recursos en Windows...")
		time.Sleep(3 * time.Second)
	}
}

// logProcessInfo muestra informaci√≥n de los procesos en ejecuci√≥n
func logProcessInfo() {
	log.Println("üìä Procesos en ejecuci√≥n:")
	
	if apiProcess != nil {
		log.Printf("   - API Server: PID %d", apiProcess.Pid)
	}
	
	if workerProcess != nil {
		log.Printf("   - Worker: PID %d", workerProcess.Pid)
	}
}

// ============================================================================
// FUNCIONES AUXILIARES
// ============================================================================

// isProcessRunning verifica si un proceso est√° corriendo
func isProcessRunning(process *os.Process) bool {
	if process == nil {
		return false
	}
	
	// En Windows, usar tasklist para verificar si el proceso existe
	if runtime.GOOS == "windows" {
		cmd := exec.Command("tasklist", "/FI", fmt.Sprintf("PID eq %d", process.Pid))
		output, err := cmd.Output()
		if err != nil {
			return false
		}
		// Si el proceso existe, tasklist incluir√° el PID en la salida
		// Verificar que la salida contenga el PID y no sea solo el header
		outputStr := string(output)
		pidStr := fmt.Sprintf("%d", process.Pid)
		return strings.Contains(outputStr, pidStr) && !strings.Contains(outputStr, "No tasks are running")
	}
	
	// En Unix/Linux, usar Signal(0)
	return process.Signal(syscall.Signal(0)) == nil
}

// waitForProcessWithTimeout espera que un proceso termine con timeout
func waitForProcessWithTimeout(process *os.Process, timeout time.Duration) error {
	if process == nil {
		return nil
	}
	
	done := make(chan error, 1)
	go func() {
		_, err := process.Wait()
		done <- err
	}()
	
	select {
	case err := <-done:
		return err
	case <-time.After(timeout):
		return fmt.Errorf("timeout esperando que termine el proceso")
	}
}

// logMemoryUsage registra el uso de memoria (solo en desarrollo)
func logMemoryUsage() {
	var memStats runtime.MemStats
	runtime.ReadMemStats(&memStats)
	
	log.Printf("üìä Memoria: Alloc=%.1fMB, Sys=%.1fMB, GC=%d",
		float64(memStats.Alloc)/1024/1024,
		float64(memStats.Sys)/1024/1024,
		memStats.NumGC)
}